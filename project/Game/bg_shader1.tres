[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

const int RECURSION_LIMIT = 10000;
const float PI = 3.141592653589793238;

uniform vec2 uv_offset = vec2(0.0);
uniform float uv_sacale : hint_range(0.0001, 1.0) = 1.0;
uniform float rotation : hint_range(0.0, 6.28318530718) = 0.0;

// Method for the mathematical construction of the julia set
int juliaSet (vec2 c, vec2 constant) {
	int recursionCount;
	
	vec2 z = c;
	
	for (recursionCount = 0; recursionCount < RECURSION_LIMIT; recursionCount++) {
		z = vec2 (z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + constant;
		
		if (length (z) > 2.0) {
			break;
		}
	}
	
	return recursionCount;
}

// Main method of the sahder
void fragment () {
	const vec2 constants[6] = vec2[] (
	vec2 (-0.7176, -0.3842),
	vec2 (-0.4, -0.59), // <-- !!!!!!
	vec2 (0.34, -0.05), // <-- !!!!!!
	vec2 (0.355, 0.355), // <-- !!!!!!
	vec2 (-0.54, 0.54),
	vec2 (0.355534, -0.337292)
	);
	
	vec2 iResolution = vec2(1.0 / SCREEN_PIXEL_SIZE.x, 1.0 / SCREEN_PIXEL_SIZE.y);
	vec2 uv = ((UV + 1.0) / 2.0) + uv_offset; // Normalized pixel coordinates (from 0 to 1)
	uv /= uv_sacale;
//	vec2 uv = 2.0 * (UV - 0.5 * iResolution.xy) / iResolution.y; // Normalized pixel coordinates (from 0 to 1)
	vec2 uv2 = uv; // Creates a copy of the uvs for coloring
	vec3 col = vec3 (1.0); // Color to be drawn on the screen
	
	float a = rotation; // rotation angle [rad]
//	float a = PI / 3.0; // rotation angle [rad]
	vec2 U = vec2 (cos (a), sin (a)); // U basis vector (new x axis)
	vec2 V = vec2 (-U.y, U.x); // V basis vector (new y axis)
	uv = vec2 (dot (uv, U), dot (uv, V)); // Rotationg the uv
	uv *= 0.9;
	
	vec2 c = uv;
	int recursionCount = juliaSet (c, constants[3]);
	float f = float(recursionCount) / float(RECURSION_LIMIT);
	
	float offset = 0.5;
	vec3 saturation = vec3 (1.0, 1.0, 1.0);
	float totalSaturation = 1.0;
	float ff = pow (f, 1.0 - (f * 1.0));
	col.r = smoothstep (0.0, 1.0, ff) * (uv2.x * 0.5 + 0.3);
	col.b = smoothstep (0.0, 1.0, ff) * (uv2.y * 0.5 + 0.3);
	col.g = smoothstep (0.0, 1.0, ff) * (-uv2.x * 0.5 + 0.3);
	col.rgb *= 5000.0 * saturation * totalSaturation;
	
	COLOR = vec4 (col.rgb, 1.0); // Outputs the result color to the screen
}"

[resource]
render_priority = -128
shader = SubResource( 1 )
shader_param/uv_offset = Vector2( -0.755, -0.763 )
shader_param/uv_sacale = 0.301054
shader_param/rotation = 3.11126
